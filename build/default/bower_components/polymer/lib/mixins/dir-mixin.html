<!--
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><link rel="import" href="property-accessors.html">

<script>(function () {
  'use strict';

  var HOST_DIR = /:host\(:dir\((ltr|rtl)\)\)/g;
  var HOST_DIR_REPLACMENT = ':host([dir="$1"])';
  var EL_DIR = /([\s\w-#\.\[\]\*]*):dir\((ltr|rtl)\)/g;
  var EL_DIR_REPLACMENT = ':host([dir="$2"]) $1';
  /**
   * @type {!Array<!Polymer_DirMixin>}
   */

  var DIR_INSTANCES = [];
  /** @type {MutationObserver} */

  var observer = null;
  var DOCUMENT_DIR = '';

  function getRTL() {
    DOCUMENT_DIR = document.documentElement.getAttribute('dir');
  }
  /**
   * @param {!Polymer_DirMixin} instance Instance to set RTL status on
   */


  function setRTL(instance) {
    if (!instance.__autoDirOptOut) {
      var el =
      /** @type {!HTMLElement} */
      instance;
      el.setAttribute('dir', DOCUMENT_DIR);
    }
  }

  function updateDirection() {
    getRTL();
    DOCUMENT_DIR = document.documentElement.getAttribute('dir');

    for (var i = 0; i < DIR_INSTANCES.length; i++) {
      setRTL(DIR_INSTANCES[i]);
    }
  }

  function takeRecords() {
    if (observer && observer.takeRecords().length) {
      updateDirection();
    }
  }
  /**
   * Element class mixin that allows elements to use the `:dir` CSS Selector to have
   * text direction specific styling.
   *
   * With this mixin, any stylesheet provided in the template will transform `:dir` into
   * `:host([dir])` and sync direction with the page via the element's `dir` attribute.
   *
   * Elements can opt out of the global page text direction by setting the `dir` attribute
   * directly in `ready()` or in HTML.
   *
   * Caveats:
   * - Applications must set `<html dir="ltr">` or `<html dir="rtl">` to sync direction
   * - Automatic left-to-right or right-to-left styling is sync'd with the `<html>` element only.
   * - Changing `dir` at runtime is supported.
   * - Opting out of the global direction styling is permanent
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.PropertyAccessors
   * @memberof Polymer
   */


  Polymer.DirMixin = Polymer.dedupingMixin(function (base) {
    if (!observer) {
      getRTL();
      observer = new MutationObserver(updateDirection);
      observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['dir']
      });
    }
    /**
     * @constructor
     * @extends {base}
     * @implements {Polymer_PropertyAccessors}
     */


    var elementBase = Polymer.PropertyAccessors(base);
    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_DirMixin}
     */

    var Dir =
    /*#__PURE__*/
    function (_elementBase) {
      babelHelpers.inherits(Dir, _elementBase);
      babelHelpers.createClass(Dir, null, [{
        key: "_processStyleText",

        /**
         * @override
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         */
        value: function _processStyleText(cssText, baseURI) {
          cssText = babelHelpers.get(Dir.__proto__ || Object.getPrototypeOf(Dir), "_processStyleText", this).call(this, cssText, baseURI);
          cssText = this._replaceDirInCssText(cssText);
          return cssText;
        }
        /**
         * Replace `:dir` in the given CSS text
         *
         * @param {string} text CSS text to replace DIR
         * @return {string} Modified CSS
         */

      }, {
        key: "_replaceDirInCssText",
        value: function _replaceDirInCssText(text) {
          var replacedText = text;
          replacedText = replacedText.replace(HOST_DIR, HOST_DIR_REPLACMENT);
          replacedText = replacedText.replace(EL_DIR, EL_DIR_REPLACMENT);

          if (text !== replacedText) {
            this.__activateDir = true;
          }

          return replacedText;
        }
      }]);

      function Dir() {
        var _this;

        babelHelpers.classCallCheck(this, Dir);
        _this = babelHelpers.possibleConstructorReturn(this, (Dir.__proto__ || Object.getPrototypeOf(Dir)).call(this));
        /** @type {boolean} */

        _this.__autoDirOptOut = false;
        return _this;
      }
      /**
       * @suppress {invalidCasts} Closure doesn't understand that `this` is an HTMLElement
       * @return {void}
       */


      babelHelpers.createClass(Dir, [{
        key: "ready",
        value: function ready() {
          babelHelpers.get(Dir.prototype.__proto__ || Object.getPrototypeOf(Dir.prototype), "ready", this).call(this);
          this.__autoDirOptOut =
          /** @type {!HTMLElement} */
          this.hasAttribute('dir');
        }
        /**
         * @suppress {missingProperties} If it exists on elementBase, it can be super'd
         * @return {void}
         */

      }, {
        key: "connectedCallback",
        value: function connectedCallback() {
          if (elementBase.prototype.connectedCallback) {
            babelHelpers.get(Dir.prototype.__proto__ || Object.getPrototypeOf(Dir.prototype), "connectedCallback", this).call(this);
          }

          if (this.constructor.__activateDir) {
            takeRecords();
            DIR_INSTANCES.push(this);
            setRTL(this);
          }
        }
        /**
         * @suppress {missingProperties} If it exists on elementBase, it can be super'd
         * @return {void}
         */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          if (elementBase.prototype.disconnectedCallback) {
            babelHelpers.get(Dir.prototype.__proto__ || Object.getPrototypeOf(Dir.prototype), "disconnectedCallback", this).call(this);
          }

          if (this.constructor.__activateDir) {
            var idx = DIR_INSTANCES.indexOf(this);

            if (idx > -1) {
              DIR_INSTANCES.splice(idx, 1);
            }
          }
        }
      }]);
      return Dir;
    }(elementBase);

    Dir.__activateDir = false;
    return Dir;
  });
})();</script>
